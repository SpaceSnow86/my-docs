# 复杂度分析

- 时间复杂度分析
- 空间复杂度分析

## 时间复杂度分析

所有代码的执行时间T(n)与每行代码的执行次数f(n)成正比

T(n)=O(f(n))

时间复杂度并不直接表示代码的执行时间，而表示代码执行时间`随着数据规模增长的变化趋势`

1. 只关注循环次数最多的代码

2. 加法法则：总复杂度等于`量级最大`的那段代码的复杂度

   注：**一段代码循环次数是一个已知的数字，不管该数字多大，统一被是为常量的执行时间，与n无关**

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码的复杂度的`乘积`

### 常见的时间复杂度



1. 多项式量级

   1. O(1)
   2. O(n)
   3. O(logn)
   4. O(n*logn)
   5. O(n^k)

2. 非多项式量级

   > 当数据规模n越来越大时，非多项式量级的算法执行时间会`急剧增加`

   1. O(2^n)
   2. O(n!)

![](./数据结构与算法/497a3f120b7debee07dc0d03984faf04.jpg)

## 最好、最坏、平均、均摊时间复杂度

### 平均时间复杂度

一般来说，最好、最坏时间复杂度出现概率很低，所以一般会使用`平均时间复杂度`

> 平均时间复杂度：将所有情况的时间复杂度相加，再除以所有情况的个数，得到的复杂度

但是这种平均时间复杂度并没有考虑到各个时间复杂度出现的概率，所以将每个复杂度出现的概率也考虑进入，叫做`加权平均时间复杂度`。

### 均摊时间复杂度？？

# 数据结构

## 数组

1. 线性表结构
2. 连续的内存空间和相同的数据类型

### 根据下标随即访问

由于数组是内存连续的，所以擅长根据下标使用`寻址公式`进行随即访问，根据下标随即访问的时间复杂度为O(1)

```
a[k]_address = base_address + k * type_size
```



### 低效的插入和删除

也是要保证数组的内存连续性，在插入和删除操作的时候，需要对插入、删除操作元素后面的元素进行整体的移动，就会导致效率地下。

## 链表

链表通过`指针`，将零散的内存块串联在一起

其中零散的内存块，称为`节点`

节点之间，通过指针进行连接。

由于链表使用指针将节节点进行连接，所以插入、删除操作非常简单，只需更改相对应的指针和节点即可，时间复杂度为O(1)。而随机访问则会很麻烦，因为要从头节点，通过指针进行遍历，之间复杂度为O(n).

- 单向链表
  - next指针
  - 尾节点的next指针指向null
- 双向链表
  - priv指针和next指针
- 循环链表
  - 尾节点指针指向头节点

## 栈

> 当数据集合只涉及一端的插入、删除操作，并且满足先入后厨的特性，这是就应该使用栈

栈相比较数组和链表而言，没有那么多暴露的接口，相对来说`比较可控`

入栈、出栈操作，只设计栈顶的元素，所以时间复杂度均为O(1)

- 入栈 push
- 出栈 pop

### 在软件工程中的应用

1. 栈空间
2. 表达式求值
3. ……

## 队列

> 先进先出
>
> 针对大部分资源有限的场景，当没有空闲的资源时，基本上都可以使用队列来实现请求排队

- 入队 enqueue
- 出队 dequeue

### 顺序队列、链式队列

因为数据需要从一段进入，另一端出去，所以队列中的所有元素相对于整合队列来说，属于一个“前进”的状态。我们在定义一个队列时，会再定义两个指针，head（头）指针和tail（尾）指针。

- 当head和tail相同时，队列为空。
- 当tail=队列长度-1时，表明队列尾部已经没空内存空间；但是如果之前有出队的元素，说明队首有空间可以使用，是我们需要进行`数据搬移`

### 循环队列

队列为循环结构，以为这如果tail=队列长度-1时，再插入元素，若之前有出队元素，直接可以插入到队首，级tail=0

循环队列避免了数据整理

循环队列队满判定条件:**（tail+1）%n=head**

### 阻塞队列和并发队列

- 阻塞队列：若队列为空，出队操作阻塞；若队列已满，入队操作阻塞。-生产者消费者模式
- 并发队列：加锁、CAS

# 算法

## 递归

### 满足递归的三个条件

1. 一个问题可以拆分为多个子问题
2. 该问题与子问题求解思路完全一样
3. 存在终止条件

### 注意问题

1. 堆栈溢出
2. 重复计算
3. 空间复杂度高

### example

```java
package priv.ihch17.recursive;

/**
 * 递归
 * n阶台阶，每次只能上1-2阶，共有集中方法
 * 思路：
 * 1. 先设定一共有f(n)种方法，
 * 2. 每次上台阶有两种方法，分别是上1阶和上两阶；分别对应n-1、n-2，将这两种方法加入到f(n)总数中，即f(n)=f(n-1)+f(n-2)，并对此进行递归
 * 3. 终止条件：当只剩下1阶台阶的时候，只能上1阶；当剩下2阶台阶的时候，有两种方法：分别为上两次1阶和上1次两阶
 */
public class Recursive {

    public static void main(String[] args) {

        int method = method(100);
        System.out.println(method);

    }

    static int method(int a){
        int result = 0;
        // 当剩下1阶时，只有一种方法
        if(a == 1){
            result =1;
        }
        // 当剩下两阶台阶时，有两种方法
        else if(a == 2){
            result = 2;
        }else{
            result = method(a-1)+method(a-2);
        }
        return result;
    }
}
```

## 排序

| 排序算法         | 时间复杂度 |
| ---------------- | ---------- |
| 冒泡、插入、选择 | O(n^2)     |
| 快排、归并       | O(nlogn)   |
| 桶、计数、基数   | O(n)       |

排序算法分析：

1. 执行效率
   1. 最好、最坏、平均时间复杂度
   2. 时间复杂度的系数、常数、低阶
   3. 比较次数和交换（移动）次数

2. 内存消耗

3. 稳定性

   待排序的序列中含有相等的元素，在排序完成后，相等元素之间的`前后顺序不变`

### 冒泡排序 （Bubble sort）

> 操作相邻的两个数据，每次冒泡对这两个数据进行比较，看是否满足排序要求
>
> 如果不满足，两个数据就进行互换
>
> 一次冒泡至少会让一个元素到达指定位置

1. 稳定排序
2. 原地排序
3. 时间复杂度O(n^2)

