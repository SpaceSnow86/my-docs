# 复杂度分析

- 时间复杂度分析
- 空间复杂度分析

## 时间复杂度分析

所有代码的执行时间T(n)与每行代码的执行次数f(n)成正比

T(n)=O(f(n))

时间复杂度并不直接表示代码的执行时间，而表示代码执行时间`随着数据规模增长的变化趋势`

1. 只关注循环次数最多的代码

2. 加法法则：总复杂度等于`量级最大`的那段代码的复杂度

   注：**一段代码循环次数是一个已知的数字，不管该数字多大，统一被是为常量的执行时间，与n无关**

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码的复杂度的`乘积`

### 常见的时间复杂度



1. 多项式量级

   1. O(1)
   2. O(n)
   3. O(logn)
   4. O(n*logn)
   5. O(n^k)

2. 非多项式量级

   > 当数据规模n越来越大时，非多项式量级的算法执行时间会`急剧增加`

   1. O(2^n)
   2. O(n!)

![](./数据结构与算法/497a3f120b7debee07dc0d03984faf04.jpg)

## 最好、最坏、平均、均摊时间复杂度

### 平均时间复杂度

一般来说，最好、最坏时间复杂度出现概率很低，所以一般会使用`平均时间复杂度`

> 平均时间复杂度：将所有情况的时间复杂度相加，再除以所有情况的个数，得到的复杂度

但是这种平均时间复杂度并没有考虑到各个时间复杂度出现的概率，所以将每个复杂度出现的概率也考虑进入，叫做`加权平均时间复杂度`。

### 均摊时间复杂度？？

# 数据结构

## 数组

1. 线性表结构
2. 连续的内存空间和相同的数据类型

### 根据下标随即访问

由于数组是内存连续的，所以擅长根据下标使用`寻址公式`进行随即访问，根据下标随即访问的时间复杂度为O(1)

```
a[k]_address = base_address + k * type_size
```



### 低效的插入和删除

也是要保证数组的内存连续性，在插入和删除操作的时候，需要对插入、删除操作元素后面的元素进行整体的移动，就会导致效率地下。

## 链表

链表通过`指针`，将零散的内存块串联在一起

其中零散的内存块，称为`节点`

节点之间，通过指针进行连接。

由于链表使用指针将节节点进行连接，所以插入、删除操作非常简单，只需更改相对应的指针和节点即可，时间复杂度为O(1)。而随机访问则会很麻烦，因为要从头节点，通过指针进行遍历，之间复杂度为O(n).

- 单向链表
  - next指针
  - 尾节点的next指针指向null
- 双向链表
  - priv指针和next指针
- 循环链表
  - 尾节点指针指向头节点

## 栈

> 先进后出 	

入栈、出栈操作，只设计栈顶的元素，所以时间复杂度均为O(1)

